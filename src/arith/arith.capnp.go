// Code generated by capnpc-go. DO NOT EDIT.

package arith

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
)

type Arith capnp.Client

// Arith_TypeID is the unique identifier for the type Arith.
const Arith_TypeID = 0xc7d2e72b14336327

func (c Arith) Multiply(ctx context.Context, params func(Arith_multiply_Params) error) (Arith_multiply_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc7d2e72b14336327,
			MethodID:      0,
			InterfaceName: "src/arith/arith.capnp:Arith",
			MethodName:    "multiply",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 16, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Arith_multiply_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Arith_multiply_Results_Future{Future: ans.Future()}, release

}

func (c Arith) Divide(ctx context.Context, params func(Arith_divide_Params) error) (Arith_divide_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc7d2e72b14336327,
			MethodID:      1,
			InterfaceName: "src/arith/arith.capnp:Arith",
			MethodName:    "divide",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 16, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Arith_divide_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Arith_divide_Results_Future{Future: ans.Future()}, release

}

func (c Arith) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Arith) String() string {
	return "Arith(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Arith) AddRef() Arith {
	return Arith(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Arith) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Arith) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Arith) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Arith) DecodeFromPtr(p capnp.Ptr) Arith {
	return Arith(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Arith) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Arith) IsSame(other Arith) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Arith) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Arith) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Arith_Server is a Arith with a local implementation.
type Arith_Server interface {
	Multiply(context.Context, Arith_multiply) error

	Divide(context.Context, Arith_divide) error
}

// Arith_NewServer creates a new Server from an implementation of Arith_Server.
func Arith_NewServer(s Arith_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Arith_Methods(nil, s), s, c)
}

// Arith_ServerToClient creates a new Client from an implementation of Arith_Server.
// The caller is responsible for calling Release on the returned Client.
func Arith_ServerToClient(s Arith_Server) Arith {
	return Arith(capnp.NewClient(Arith_NewServer(s)))
}

// Arith_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Arith_Methods(methods []server.Method, s Arith_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc7d2e72b14336327,
			MethodID:      0,
			InterfaceName: "src/arith/arith.capnp:Arith",
			MethodName:    "multiply",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Multiply(ctx, Arith_multiply{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc7d2e72b14336327,
			MethodID:      1,
			InterfaceName: "src/arith/arith.capnp:Arith",
			MethodName:    "divide",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Divide(ctx, Arith_divide{call})
		},
	})

	return methods
}

// Arith_multiply holds the state for a server call to Arith.multiply.
// See server.Call for documentation.
type Arith_multiply struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Arith_multiply) Args() Arith_multiply_Params {
	return Arith_multiply_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Arith_multiply) AllocResults() (Arith_multiply_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Arith_multiply_Results(r), err
}

// Arith_divide holds the state for a server call to Arith.divide.
// See server.Call for documentation.
type Arith_divide struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Arith_divide) Args() Arith_divide_Params {
	return Arith_divide_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Arith_divide) AllocResults() (Arith_divide_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Arith_divide_Results(r), err
}

// Arith_List is a list of Arith.
type Arith_List = capnp.CapList[Arith]

// NewArith_List creates a new list of Arith.
func NewArith_List(s *capnp.Segment, sz int32) (Arith_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Arith](l), err
}

type Arith_multiply_Params capnp.Struct

// Arith_multiply_Params_TypeID is the unique identifier for the type Arith_multiply_Params.
const Arith_multiply_Params_TypeID = 0xbd415b27d345b330

func NewArith_multiply_Params(s *capnp.Segment) (Arith_multiply_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Arith_multiply_Params(st), err
}

func NewRootArith_multiply_Params(s *capnp.Segment) (Arith_multiply_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Arith_multiply_Params(st), err
}

func ReadRootArith_multiply_Params(msg *capnp.Message) (Arith_multiply_Params, error) {
	root, err := msg.Root()
	return Arith_multiply_Params(root.Struct()), err
}

func (s Arith_multiply_Params) String() string {
	str, _ := text.Marshal(0xbd415b27d345b330, capnp.Struct(s))
	return str
}

func (s Arith_multiply_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Arith_multiply_Params) DecodeFromPtr(p capnp.Ptr) Arith_multiply_Params {
	return Arith_multiply_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Arith_multiply_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Arith_multiply_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Arith_multiply_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Arith_multiply_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Arith_multiply_Params) A() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Arith_multiply_Params) SetA(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Arith_multiply_Params) B() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Arith_multiply_Params) SetB(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

// Arith_multiply_Params_List is a list of Arith_multiply_Params.
type Arith_multiply_Params_List = capnp.StructList[Arith_multiply_Params]

// NewArith_multiply_Params creates a new list of Arith_multiply_Params.
func NewArith_multiply_Params_List(s *capnp.Segment, sz int32) (Arith_multiply_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Arith_multiply_Params](l), err
}

// Arith_multiply_Params_Future is a wrapper for a Arith_multiply_Params promised by a client call.
type Arith_multiply_Params_Future struct{ *capnp.Future }

func (f Arith_multiply_Params_Future) Struct() (Arith_multiply_Params, error) {
	p, err := f.Future.Ptr()
	return Arith_multiply_Params(p.Struct()), err
}

type Arith_multiply_Results capnp.Struct

// Arith_multiply_Results_TypeID is the unique identifier for the type Arith_multiply_Results.
const Arith_multiply_Results_TypeID = 0x9eea8e29bc767851

func NewArith_multiply_Results(s *capnp.Segment) (Arith_multiply_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Arith_multiply_Results(st), err
}

func NewRootArith_multiply_Results(s *capnp.Segment) (Arith_multiply_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Arith_multiply_Results(st), err
}

func ReadRootArith_multiply_Results(msg *capnp.Message) (Arith_multiply_Results, error) {
	root, err := msg.Root()
	return Arith_multiply_Results(root.Struct()), err
}

func (s Arith_multiply_Results) String() string {
	str, _ := text.Marshal(0x9eea8e29bc767851, capnp.Struct(s))
	return str
}

func (s Arith_multiply_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Arith_multiply_Results) DecodeFromPtr(p capnp.Ptr) Arith_multiply_Results {
	return Arith_multiply_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Arith_multiply_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Arith_multiply_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Arith_multiply_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Arith_multiply_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Arith_multiply_Results) Product() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Arith_multiply_Results) SetProduct(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

// Arith_multiply_Results_List is a list of Arith_multiply_Results.
type Arith_multiply_Results_List = capnp.StructList[Arith_multiply_Results]

// NewArith_multiply_Results creates a new list of Arith_multiply_Results.
func NewArith_multiply_Results_List(s *capnp.Segment, sz int32) (Arith_multiply_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Arith_multiply_Results](l), err
}

// Arith_multiply_Results_Future is a wrapper for a Arith_multiply_Results promised by a client call.
type Arith_multiply_Results_Future struct{ *capnp.Future }

func (f Arith_multiply_Results_Future) Struct() (Arith_multiply_Results, error) {
	p, err := f.Future.Ptr()
	return Arith_multiply_Results(p.Struct()), err
}

type Arith_divide_Params capnp.Struct

// Arith_divide_Params_TypeID is the unique identifier for the type Arith_divide_Params.
const Arith_divide_Params_TypeID = 0xca26060ad826cd65

func NewArith_divide_Params(s *capnp.Segment) (Arith_divide_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Arith_divide_Params(st), err
}

func NewRootArith_divide_Params(s *capnp.Segment) (Arith_divide_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Arith_divide_Params(st), err
}

func ReadRootArith_divide_Params(msg *capnp.Message) (Arith_divide_Params, error) {
	root, err := msg.Root()
	return Arith_divide_Params(root.Struct()), err
}

func (s Arith_divide_Params) String() string {
	str, _ := text.Marshal(0xca26060ad826cd65, capnp.Struct(s))
	return str
}

func (s Arith_divide_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Arith_divide_Params) DecodeFromPtr(p capnp.Ptr) Arith_divide_Params {
	return Arith_divide_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Arith_divide_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Arith_divide_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Arith_divide_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Arith_divide_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Arith_divide_Params) Num() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Arith_divide_Params) SetNum(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Arith_divide_Params) Denom() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Arith_divide_Params) SetDenom(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

// Arith_divide_Params_List is a list of Arith_divide_Params.
type Arith_divide_Params_List = capnp.StructList[Arith_divide_Params]

// NewArith_divide_Params creates a new list of Arith_divide_Params.
func NewArith_divide_Params_List(s *capnp.Segment, sz int32) (Arith_divide_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Arith_divide_Params](l), err
}

// Arith_divide_Params_Future is a wrapper for a Arith_divide_Params promised by a client call.
type Arith_divide_Params_Future struct{ *capnp.Future }

func (f Arith_divide_Params_Future) Struct() (Arith_divide_Params, error) {
	p, err := f.Future.Ptr()
	return Arith_divide_Params(p.Struct()), err
}

type Arith_divide_Results capnp.Struct

// Arith_divide_Results_TypeID is the unique identifier for the type Arith_divide_Results.
const Arith_divide_Results_TypeID = 0x9ca77bf85167b605

func NewArith_divide_Results(s *capnp.Segment) (Arith_divide_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Arith_divide_Results(st), err
}

func NewRootArith_divide_Results(s *capnp.Segment) (Arith_divide_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Arith_divide_Results(st), err
}

func ReadRootArith_divide_Results(msg *capnp.Message) (Arith_divide_Results, error) {
	root, err := msg.Root()
	return Arith_divide_Results(root.Struct()), err
}

func (s Arith_divide_Results) String() string {
	str, _ := text.Marshal(0x9ca77bf85167b605, capnp.Struct(s))
	return str
}

func (s Arith_divide_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Arith_divide_Results) DecodeFromPtr(p capnp.Ptr) Arith_divide_Results {
	return Arith_divide_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Arith_divide_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Arith_divide_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Arith_divide_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Arith_divide_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Arith_divide_Results) Quotient() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Arith_divide_Results) SetQuotient(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Arith_divide_Results) Remainder() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Arith_divide_Results) SetRemainder(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

// Arith_divide_Results_List is a list of Arith_divide_Results.
type Arith_divide_Results_List = capnp.StructList[Arith_divide_Results]

// NewArith_divide_Results creates a new list of Arith_divide_Results.
func NewArith_divide_Results_List(s *capnp.Segment, sz int32) (Arith_divide_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Arith_divide_Results](l), err
}

// Arith_divide_Results_Future is a wrapper for a Arith_divide_Results promised by a client call.
type Arith_divide_Results_Future struct{ *capnp.Future }

func (f Arith_divide_Results_Future) Struct() (Arith_divide_Results, error) {
	p, err := f.Future.Ptr()
	return Arith_divide_Results(p.Struct()), err
}

type Number capnp.Struct

// Number_TypeID is the unique identifier for the type Number.
const Number_TypeID = 0xedaa70b95d83d6bb

func NewNumber(s *capnp.Segment) (Number, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Number(st), err
}

func NewRootNumber(s *capnp.Segment) (Number, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Number(st), err
}

func ReadRootNumber(msg *capnp.Message) (Number, error) {
	root, err := msg.Root()
	return Number(root.Struct()), err
}

func (s Number) String() string {
	str, _ := text.Marshal(0xedaa70b95d83d6bb, capnp.Struct(s))
	return str
}

func (s Number) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Number) DecodeFromPtr(p capnp.Ptr) Number {
	return Number(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Number) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Number) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Number) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Number) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Number) Value() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Number) SetValue(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

// Number_List is a list of Number.
type Number_List = capnp.StructList[Number]

// NewNumber creates a new list of Number.
func NewNumber_List(s *capnp.Segment, sz int32) (Number_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Number](l), err
}

// Number_Future is a wrapper for a Number promised by a client call.
type Number_Future struct{ *capnp.Future }

func (f Number_Future) Struct() (Number, error) {
	p, err := f.Future.Ptr()
	return Number(p.Struct()), err
}

type Number_Ops capnp.Client

// Number_Ops_TypeID is the unique identifier for the type Number_Ops.
const Number_Ops_TypeID = 0x861f401c46c3e9fb

func (c Number_Ops) Plus(ctx context.Context, params func(Number_Ops_plus_Params) error) (Number_Ops_plus_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x861f401c46c3e9fb,
			MethodID:      0,
			InterfaceName: "src/arith/arith.capnp:Number.Ops",
			MethodName:    "plus",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 8, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Number_Ops_plus_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Number_Ops_plus_Results_Future{Future: ans.Future()}, release

}

func (c Number_Ops) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Number_Ops) String() string {
	return "Number_Ops(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Number_Ops) AddRef() Number_Ops {
	return Number_Ops(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Number_Ops) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Number_Ops) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Number_Ops) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Number_Ops) DecodeFromPtr(p capnp.Ptr) Number_Ops {
	return Number_Ops(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Number_Ops) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Number_Ops) IsSame(other Number_Ops) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Number_Ops) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Number_Ops) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Number_Ops_Server is a Number_Ops with a local implementation.
type Number_Ops_Server interface {
	Plus(context.Context, Number_Ops_plus) error
}

// Number_Ops_NewServer creates a new Server from an implementation of Number_Ops_Server.
func Number_Ops_NewServer(s Number_Ops_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Number_Ops_Methods(nil, s), s, c)
}

// Number_Ops_ServerToClient creates a new Client from an implementation of Number_Ops_Server.
// The caller is responsible for calling Release on the returned Client.
func Number_Ops_ServerToClient(s Number_Ops_Server) Number_Ops {
	return Number_Ops(capnp.NewClient(Number_Ops_NewServer(s)))
}

// Number_Ops_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Number_Ops_Methods(methods []server.Method, s Number_Ops_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x861f401c46c3e9fb,
			MethodID:      0,
			InterfaceName: "src/arith/arith.capnp:Number.Ops",
			MethodName:    "plus",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Plus(ctx, Number_Ops_plus{call})
		},
	})

	return methods
}

// Number_Ops_plus holds the state for a server call to Number_Ops.plus.
// See server.Call for documentation.
type Number_Ops_plus struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Number_Ops_plus) Args() Number_Ops_plus_Params {
	return Number_Ops_plus_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Number_Ops_plus) AllocResults() (Number_Ops_plus_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Number_Ops_plus_Results(r), err
}

// Number_Ops_List is a list of Number_Ops.
type Number_Ops_List = capnp.CapList[Number_Ops]

// NewNumber_Ops_List creates a new list of Number_Ops.
func NewNumber_Ops_List(s *capnp.Segment, sz int32) (Number_Ops_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Number_Ops](l), err
}

type Number_Ops_plus_Params capnp.Struct

// Number_Ops_plus_Params_TypeID is the unique identifier for the type Number_Ops_plus_Params.
const Number_Ops_plus_Params_TypeID = 0xf43affa373e603dd

func NewNumber_Ops_plus_Params(s *capnp.Segment) (Number_Ops_plus_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Number_Ops_plus_Params(st), err
}

func NewRootNumber_Ops_plus_Params(s *capnp.Segment) (Number_Ops_plus_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Number_Ops_plus_Params(st), err
}

func ReadRootNumber_Ops_plus_Params(msg *capnp.Message) (Number_Ops_plus_Params, error) {
	root, err := msg.Root()
	return Number_Ops_plus_Params(root.Struct()), err
}

func (s Number_Ops_plus_Params) String() string {
	str, _ := text.Marshal(0xf43affa373e603dd, capnp.Struct(s))
	return str
}

func (s Number_Ops_plus_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Number_Ops_plus_Params) DecodeFromPtr(p capnp.Ptr) Number_Ops_plus_Params {
	return Number_Ops_plus_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Number_Ops_plus_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Number_Ops_plus_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Number_Ops_plus_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Number_Ops_plus_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Number_Ops_plus_Params) ValueToAdd() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Number_Ops_plus_Params) SetValueToAdd(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

// Number_Ops_plus_Params_List is a list of Number_Ops_plus_Params.
type Number_Ops_plus_Params_List = capnp.StructList[Number_Ops_plus_Params]

// NewNumber_Ops_plus_Params creates a new list of Number_Ops_plus_Params.
func NewNumber_Ops_plus_Params_List(s *capnp.Segment, sz int32) (Number_Ops_plus_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Number_Ops_plus_Params](l), err
}

// Number_Ops_plus_Params_Future is a wrapper for a Number_Ops_plus_Params promised by a client call.
type Number_Ops_plus_Params_Future struct{ *capnp.Future }

func (f Number_Ops_plus_Params_Future) Struct() (Number_Ops_plus_Params, error) {
	p, err := f.Future.Ptr()
	return Number_Ops_plus_Params(p.Struct()), err
}

type Number_Ops_plus_Results capnp.Struct

// Number_Ops_plus_Results_TypeID is the unique identifier for the type Number_Ops_plus_Results.
const Number_Ops_plus_Results_TypeID = 0xfec8cc3e077be88d

func NewNumber_Ops_plus_Results(s *capnp.Segment) (Number_Ops_plus_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Number_Ops_plus_Results(st), err
}

func NewRootNumber_Ops_plus_Results(s *capnp.Segment) (Number_Ops_plus_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Number_Ops_plus_Results(st), err
}

func ReadRootNumber_Ops_plus_Results(msg *capnp.Message) (Number_Ops_plus_Results, error) {
	root, err := msg.Root()
	return Number_Ops_plus_Results(root.Struct()), err
}

func (s Number_Ops_plus_Results) String() string {
	str, _ := text.Marshal(0xfec8cc3e077be88d, capnp.Struct(s))
	return str
}

func (s Number_Ops_plus_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Number_Ops_plus_Results) DecodeFromPtr(p capnp.Ptr) Number_Ops_plus_Results {
	return Number_Ops_plus_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Number_Ops_plus_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Number_Ops_plus_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Number_Ops_plus_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Number_Ops_plus_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Number_Ops_plus_Results) Sum() (Number, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Number(p.Struct()), err
}

func (s Number_Ops_plus_Results) HasSum() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Number_Ops_plus_Results) SetSum(v Number) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSum sets the sum field to a newly
// allocated Number struct, preferring placement in s's segment.
func (s Number_Ops_plus_Results) NewSum() (Number, error) {
	ss, err := NewNumber(capnp.Struct(s).Segment())
	if err != nil {
		return Number{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Number_Ops_plus_Results_List is a list of Number_Ops_plus_Results.
type Number_Ops_plus_Results_List = capnp.StructList[Number_Ops_plus_Results]

// NewNumber_Ops_plus_Results creates a new list of Number_Ops_plus_Results.
func NewNumber_Ops_plus_Results_List(s *capnp.Segment, sz int32) (Number_Ops_plus_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Number_Ops_plus_Results](l), err
}

// Number_Ops_plus_Results_Future is a wrapper for a Number_Ops_plus_Results promised by a client call.
type Number_Ops_plus_Results_Future struct{ *capnp.Future }

func (f Number_Ops_plus_Results_Future) Struct() (Number_Ops_plus_Results, error) {
	p, err := f.Future.Ptr()
	return Number_Ops_plus_Results(p.Struct()), err
}
func (p Number_Ops_plus_Results_Future) Sum() Number_Future {
	return Number_Future{Future: p.Future.Field(0, nil)}
}

const schema_c8e5b86f8a9fb4d0 = "x\xda\x94\x94Mh\x13[\x1c\xc5\xcf\xff\xde\x99N)" +
	"\xaf\xa4\xd3)}o\xd1\x12Z\xfa\xf1\xfa\x1e\xadI[" +
	"7El\"T\xa1\xd067\xe8\xc2\x8a\x8bi2\xd8" +
	"H&\x19\xe7\xa3*]t!(\x0a\xea\xca\x9d(\xe2" +
	"Bp'\x8a(\xda\x95\x0b\x8b(\x88\x82\xb8\xe9F\xf0" +
	"\xa3\x05\x17\x82\x0bAt\xe4F\xf3U\xc5\xdaU.\xe1" +
	"\xf0\xbb\xe7p\xce\x9d\xd8yJ(\xf1\xe6%\x05L\x8c" +
	"\xaa\x0d\xe1\xe7\xb5\x07\xbb;\x12\xd1\x93\xd0;yx\xef" +
	"\xc5\x89\x83w\x9d\xeb\xef\x01\x1a\xe9eMdlg\x1a" +
	"`\xc4\xd9\x1ec\xbf<\x85\xea\xedC\xe2\xd3\xe2\xb5\x8b" +
	"\x10\x1d\xc4\x00E\x03F\x92l\x96@\xc6\x14;\x0a\x0a" +
	"\xc5\xb1\x85\xfb\x03\xe7\xd6/I\x01\xfd\x10\xdc`\x87\xa5" +
	"`\x99\x8d\x83\xc2\xd8\xcd\x89\xe7\xfd\x07\x92\xcb\xb5\x84U" +
	"6'\x05k%B\x7ff\xa4\xed\xff\xb7\xcf\x1eBo" +
	"\xe7\xe1\xd3[\x97\xcf\x14\xef\xbc^\x01\xc8\x98\xe0\xaf\x0c" +
	"\xc1\xa5\x9f)~\xca\xb8\"O\xa1\xf5\xa4\xefeSC" +
	"\xdf\xa3Z\xdai\x9e\x96\xb4\x0b\\\xd2*\x89D;Q" +
	"\x15'\x85\xc6\x07\xben|\xe1\x7f\x03\x86\xaaHk\xab" +
	"\xfc\x8dw5\x1c\xfb\x08\xd1U\xf1\xde\xab\x94\xbc\xc7K" +
	"\x82\xb3\xef\x16\xb5\x9d\x8fW\xbeB\xef\"@%)\xd8" +
	"\xa7\xb8R`*\xe3\x18\x0c=7\xb3\xcdts>\x9f" +
	"/\xfd\xcc\x0feL\xa7\xe0\x8cM\x07\xf6\x9c\xe5\x0e\xcd" +
	"8\x1e\x90\"\x12\x0aW\x81\xcauT\xc6\xea\xfa\x7f`" +
	"\xba\xaaE\x9c|\xe0%(ET\x01*\xf5\xc0d\xe9" +
	"\x9c\xcd-\xe4\xb2VO\xda\xf2\x82<\xf7=\xd1\xc8\x15" +
	"@!@\x1f\x98\x04\xc4\xbf\x9c\xc4(#\x9d\xa8M\xc6" +
	"\xd1\xe3i@\xc48\x89\x1d\x8c\xc2#A\xd1\xcfY\x05" +
	"\x1f\x00\xa9`\xa4\x82B\xd7\xb2\xcd\\!k\x81\xdc\xca" +
	"\x7f\xbf5`\x07y?\xe7\xe4\x8fK\x0b\x91 \xef{" +
	"B\xa9Xh\xde\x05\x88FN\xa2\x8d\xd1\x92\xe3\x16\xb3" +
	"A\xc6\xdf\"5e\xba\x9ai\xd7\xe5j\x05D\x0f'" +
	"\x11\xab\xc95\xd8Z\x0dKf\xf9\x0e\x9a\xfb\xe96\xb6" +
	"\xf16-\xe7\xcf\xcb>\x1aK}\x94\x97I\xe5\x0d\xeb" +
	"\xf1I0}@#\xaa\xec\x8c\xca\x0f@\xef\x1c\x03\xd3" +
	"u-,\xbb\x05\x90\xa0\xf1\xef\x95\xfcyw)\xd35" +
	"m\xaa\x8b\xd8\xfd\xab\x88\xc3\xd5\x88Z!\xb0\xcb\xd1\xa2" +
	"Y\xabP\xb47\x0b:\x1dD\xe4\xfe\x84BT\xf3\xdc" +
	"\xa9[\x9bq\xea\x1a\x1b\xae6\x16]0\xf3\x81\xb5Y" +
	"_\xd5]\x0f\xc9\xc9\xf6\xa4\xcc\x88+\x0b\xaba\xce\x02" +
	"\xe2/N\xe2\x1fFa\x89\xb9\xb7\x98\x04\xcff\xb7\x8a" +
	"N[Qo\xe3\xc2\xba\xab~5/\xb0\xa9\xa5\xf6\xfb" +
	"E-\xa0o\x01\x00\x00\xff\xff\xd3\x0fJ\x82"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_c8e5b86f8a9fb4d0,
		Nodes: []uint64{
			0x861f401c46c3e9fb,
			0x9ca77bf85167b605,
			0x9eea8e29bc767851,
			0xbd415b27d345b330,
			0xc7d2e72b14336327,
			0xca26060ad826cd65,
			0xedaa70b95d83d6bb,
			0xf43affa373e603dd,
			0xfec8cc3e077be88d,
		},
		Compressed: true,
	})
}
