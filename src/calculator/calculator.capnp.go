// Code generated by capnpc-go. DO NOT EDIT.

package calculator

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	strconv "strconv"
)

type Calculator capnp.Client

// Calculator_TypeID is the unique identifier for the type Calculator.
const Calculator_TypeID = 0x8e2bd90d51b647e6

func (c Calculator) Add(ctx context.Context, params func(Calculator_InputPair) error) (Calculator_Output_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8e2bd90d51b647e6,
			MethodID:      0,
			InterfaceName: "src/calculator/calculator.capnp:Calculator",
			MethodName:    "add",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 2}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Calculator_InputPair(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Calculator_Output_Future{Future: ans.Future()}, release

}

func (c Calculator) Sub(ctx context.Context, params func(Calculator_InputPair) error) (Calculator_Output_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8e2bd90d51b647e6,
			MethodID:      1,
			InterfaceName: "src/calculator/calculator.capnp:Calculator",
			MethodName:    "sub",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 2}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Calculator_InputPair(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Calculator_Output_Future{Future: ans.Future()}, release

}

func (c Calculator) Mul(ctx context.Context, params func(Calculator_InputPair) error) (Calculator_Output_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8e2bd90d51b647e6,
			MethodID:      2,
			InterfaceName: "src/calculator/calculator.capnp:Calculator",
			MethodName:    "mul",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 2}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Calculator_InputPair(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Calculator_Output_Future{Future: ans.Future()}, release

}

func (c Calculator) Div(ctx context.Context, params func(Calculator_InputPair) error) (Calculator_Output_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8e2bd90d51b647e6,
			MethodID:      3,
			InterfaceName: "src/calculator/calculator.capnp:Calculator",
			MethodName:    "div",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 2}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Calculator_InputPair(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Calculator_Output_Future{Future: ans.Future()}, release

}

func (c Calculator) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Calculator) String() string {
	return "Calculator(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Calculator) AddRef() Calculator {
	return Calculator(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Calculator) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Calculator) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Calculator) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Calculator) DecodeFromPtr(p capnp.Ptr) Calculator {
	return Calculator(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Calculator) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Calculator) IsSame(other Calculator) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Calculator) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Calculator) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Calculator_Server is a Calculator with a local implementation.
type Calculator_Server interface {
	Add(context.Context, Calculator_add) error

	Sub(context.Context, Calculator_sub) error

	Mul(context.Context, Calculator_mul) error

	Div(context.Context, Calculator_div) error
}

// Calculator_NewServer creates a new Server from an implementation of Calculator_Server.
func Calculator_NewServer(s Calculator_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Calculator_Methods(nil, s), s, c)
}

// Calculator_ServerToClient creates a new Client from an implementation of Calculator_Server.
// The caller is responsible for calling Release on the returned Client.
func Calculator_ServerToClient(s Calculator_Server) Calculator {
	return Calculator(capnp.NewClient(Calculator_NewServer(s)))
}

// Calculator_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Calculator_Methods(methods []server.Method, s Calculator_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 4)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8e2bd90d51b647e6,
			MethodID:      0,
			InterfaceName: "src/calculator/calculator.capnp:Calculator",
			MethodName:    "add",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Add(ctx, Calculator_add{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8e2bd90d51b647e6,
			MethodID:      1,
			InterfaceName: "src/calculator/calculator.capnp:Calculator",
			MethodName:    "sub",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Sub(ctx, Calculator_sub{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8e2bd90d51b647e6,
			MethodID:      2,
			InterfaceName: "src/calculator/calculator.capnp:Calculator",
			MethodName:    "mul",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Mul(ctx, Calculator_mul{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8e2bd90d51b647e6,
			MethodID:      3,
			InterfaceName: "src/calculator/calculator.capnp:Calculator",
			MethodName:    "div",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Div(ctx, Calculator_div{call})
		},
	})

	return methods
}

// Calculator_add holds the state for a server call to Calculator.add.
// See server.Call for documentation.
type Calculator_add struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Calculator_add) Args() Calculator_InputPair {
	return Calculator_InputPair(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Calculator_add) AllocResults() (Calculator_Output, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Calculator_Output(r), err
}

// Calculator_sub holds the state for a server call to Calculator.sub.
// See server.Call for documentation.
type Calculator_sub struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Calculator_sub) Args() Calculator_InputPair {
	return Calculator_InputPair(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Calculator_sub) AllocResults() (Calculator_Output, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Calculator_Output(r), err
}

// Calculator_mul holds the state for a server call to Calculator.mul.
// See server.Call for documentation.
type Calculator_mul struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Calculator_mul) Args() Calculator_InputPair {
	return Calculator_InputPair(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Calculator_mul) AllocResults() (Calculator_Output, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Calculator_Output(r), err
}

// Calculator_div holds the state for a server call to Calculator.div.
// See server.Call for documentation.
type Calculator_div struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Calculator_div) Args() Calculator_InputPair {
	return Calculator_InputPair(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Calculator_div) AllocResults() (Calculator_Output, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Calculator_Output(r), err
}

// Calculator_List is a list of Calculator.
type Calculator_List = capnp.CapList[Calculator]

// NewCalculator_List creates a new list of Calculator.
func NewCalculator_List(s *capnp.Segment, sz int32) (Calculator_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Calculator](l), err
}

type Calculator_InputPair capnp.Struct

// Calculator_InputPair_TypeID is the unique identifier for the type Calculator_InputPair.
const Calculator_InputPair_TypeID = 0xd0ba49bd3cc8c5b7

func NewCalculator_InputPair(s *capnp.Segment) (Calculator_InputPair, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Calculator_InputPair(st), err
}

func NewRootCalculator_InputPair(s *capnp.Segment) (Calculator_InputPair, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Calculator_InputPair(st), err
}

func ReadRootCalculator_InputPair(msg *capnp.Message) (Calculator_InputPair, error) {
	root, err := msg.Root()
	return Calculator_InputPair(root.Struct()), err
}

func (s Calculator_InputPair) String() string {
	str, _ := text.Marshal(0xd0ba49bd3cc8c5b7, capnp.Struct(s))
	return str
}

func (s Calculator_InputPair) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Calculator_InputPair) DecodeFromPtr(p capnp.Ptr) Calculator_InputPair {
	return Calculator_InputPair(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Calculator_InputPair) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Calculator_InputPair) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Calculator_InputPair) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Calculator_InputPair) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Calculator_InputPair) Left() (Calculator_Input, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Calculator_Input(p.Struct()), err
}

func (s Calculator_InputPair) HasLeft() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Calculator_InputPair) SetLeft(v Calculator_Input) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewLeft sets the left field to a newly
// allocated Calculator_Input struct, preferring placement in s's segment.
func (s Calculator_InputPair) NewLeft() (Calculator_Input, error) {
	ss, err := NewCalculator_Input(capnp.Struct(s).Segment())
	if err != nil {
		return Calculator_Input{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Calculator_InputPair) Right() (Calculator_Input, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Calculator_Input(p.Struct()), err
}

func (s Calculator_InputPair) HasRight() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Calculator_InputPair) SetRight(v Calculator_Input) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewRight sets the right field to a newly
// allocated Calculator_Input struct, preferring placement in s's segment.
func (s Calculator_InputPair) NewRight() (Calculator_Input, error) {
	ss, err := NewCalculator_Input(capnp.Struct(s).Segment())
	if err != nil {
		return Calculator_Input{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Calculator_InputPair_List is a list of Calculator_InputPair.
type Calculator_InputPair_List = capnp.StructList[Calculator_InputPair]

// NewCalculator_InputPair creates a new list of Calculator_InputPair.
func NewCalculator_InputPair_List(s *capnp.Segment, sz int32) (Calculator_InputPair_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Calculator_InputPair](l), err
}

// Calculator_InputPair_Future is a wrapper for a Calculator_InputPair promised by a client call.
type Calculator_InputPair_Future struct{ *capnp.Future }

func (f Calculator_InputPair_Future) Struct() (Calculator_InputPair, error) {
	p, err := f.Future.Ptr()
	return Calculator_InputPair(p.Struct()), err
}
func (p Calculator_InputPair_Future) Left() Calculator_Input_Future {
	return Calculator_Input_Future{Future: p.Future.Field(0, nil)}
}
func (p Calculator_InputPair_Future) Right() Calculator_Input_Future {
	return Calculator_Input_Future{Future: p.Future.Field(1, nil)}
}

type Calculator_Input capnp.Struct
type Calculator_Input_Which uint16

const (
	Calculator_Input_Which_literal Calculator_Input_Which = 0
	Calculator_Input_Which_value   Calculator_Input_Which = 1
)

func (w Calculator_Input_Which) String() string {
	const s = "literalvalue"
	switch w {
	case Calculator_Input_Which_literal:
		return s[0:7]
	case Calculator_Input_Which_value:
		return s[7:12]

	}
	return "Calculator_Input_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Calculator_Input_TypeID is the unique identifier for the type Calculator_Input.
const Calculator_Input_TypeID = 0xef054ff23b2de174

func NewCalculator_Input(s *capnp.Segment) (Calculator_Input, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Calculator_Input(st), err
}

func NewRootCalculator_Input(s *capnp.Segment) (Calculator_Input, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Calculator_Input(st), err
}

func ReadRootCalculator_Input(msg *capnp.Message) (Calculator_Input, error) {
	root, err := msg.Root()
	return Calculator_Input(root.Struct()), err
}

func (s Calculator_Input) String() string {
	str, _ := text.Marshal(0xef054ff23b2de174, capnp.Struct(s))
	return str
}

func (s Calculator_Input) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Calculator_Input) DecodeFromPtr(p capnp.Ptr) Calculator_Input {
	return Calculator_Input(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Calculator_Input) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Calculator_Input) Which() Calculator_Input_Which {
	return Calculator_Input_Which(capnp.Struct(s).Uint16(4))
}
func (s Calculator_Input) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Calculator_Input) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Calculator_Input) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Calculator_Input) Literal() int32 {
	if capnp.Struct(s).Uint16(4) != 0 {
		panic("Which() != literal")
	}
	return int32(capnp.Struct(s).Uint32(0))
}

func (s Calculator_Input) SetLiteral(v int32) {
	capnp.Struct(s).SetUint16(4, 0)
	capnp.Struct(s).SetUint32(0, uint32(v))
}

func (s Calculator_Input) Value() Calculator_Value {
	if capnp.Struct(s).Uint16(4) != 1 {
		panic("Which() != value")
	}
	p, _ := capnp.Struct(s).Ptr(0)
	return Calculator_Value(p.Interface().Client())
}

func (s Calculator_Input) HasValue() bool {
	if capnp.Struct(s).Uint16(4) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Calculator_Input) SetValue(v Calculator_Value) error {
	capnp.Struct(s).SetUint16(4, 1)
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Calculator_Input_List is a list of Calculator_Input.
type Calculator_Input_List = capnp.StructList[Calculator_Input]

// NewCalculator_Input creates a new list of Calculator_Input.
func NewCalculator_Input_List(s *capnp.Segment, sz int32) (Calculator_Input_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Calculator_Input](l), err
}

// Calculator_Input_Future is a wrapper for a Calculator_Input promised by a client call.
type Calculator_Input_Future struct{ *capnp.Future }

func (f Calculator_Input_Future) Struct() (Calculator_Input, error) {
	p, err := f.Future.Ptr()
	return Calculator_Input(p.Struct()), err
}
func (p Calculator_Input_Future) Value() Calculator_Value {
	return Calculator_Value(p.Future.Field(0, nil).Client())
}

type Calculator_Output capnp.Struct

// Calculator_Output_TypeID is the unique identifier for the type Calculator_Output.
const Calculator_Output_TypeID = 0xef2c273c414b4e2b

func NewCalculator_Output(s *capnp.Segment) (Calculator_Output, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Calculator_Output(st), err
}

func NewRootCalculator_Output(s *capnp.Segment) (Calculator_Output, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Calculator_Output(st), err
}

func ReadRootCalculator_Output(msg *capnp.Message) (Calculator_Output, error) {
	root, err := msg.Root()
	return Calculator_Output(root.Struct()), err
}

func (s Calculator_Output) String() string {
	str, _ := text.Marshal(0xef2c273c414b4e2b, capnp.Struct(s))
	return str
}

func (s Calculator_Output) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Calculator_Output) DecodeFromPtr(p capnp.Ptr) Calculator_Output {
	return Calculator_Output(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Calculator_Output) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Calculator_Output) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Calculator_Output) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Calculator_Output) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Calculator_Output) Value() Calculator_Value {
	p, _ := capnp.Struct(s).Ptr(0)
	return Calculator_Value(p.Interface().Client())
}

func (s Calculator_Output) HasValue() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Calculator_Output) SetValue(v Calculator_Value) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Calculator_Output_List is a list of Calculator_Output.
type Calculator_Output_List = capnp.StructList[Calculator_Output]

// NewCalculator_Output creates a new list of Calculator_Output.
func NewCalculator_Output_List(s *capnp.Segment, sz int32) (Calculator_Output_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Calculator_Output](l), err
}

// Calculator_Output_Future is a wrapper for a Calculator_Output promised by a client call.
type Calculator_Output_Future struct{ *capnp.Future }

func (f Calculator_Output_Future) Struct() (Calculator_Output, error) {
	p, err := f.Future.Ptr()
	return Calculator_Output(p.Struct()), err
}
func (p Calculator_Output_Future) Value() Calculator_Value {
	return Calculator_Value(p.Future.Field(0, nil).Client())
}

type Calculator_Value capnp.Client

// Calculator_Value_TypeID is the unique identifier for the type Calculator_Value.
const Calculator_Value_TypeID = 0xd46de288fc9d9427

func (c Calculator_Value) Read(ctx context.Context, params func(Calculator_Value_read_Params) error) (Calculator_Value_read_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xd46de288fc9d9427,
			MethodID:      0,
			InterfaceName: "src/calculator/calculator.capnp:Calculator.Value",
			MethodName:    "read",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Calculator_Value_read_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Calculator_Value_read_Results_Future{Future: ans.Future()}, release

}

func (c Calculator_Value) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Calculator_Value) String() string {
	return "Calculator_Value(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Calculator_Value) AddRef() Calculator_Value {
	return Calculator_Value(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Calculator_Value) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Calculator_Value) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Calculator_Value) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Calculator_Value) DecodeFromPtr(p capnp.Ptr) Calculator_Value {
	return Calculator_Value(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Calculator_Value) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Calculator_Value) IsSame(other Calculator_Value) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Calculator_Value) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Calculator_Value) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Calculator_Value_Server is a Calculator_Value with a local implementation.
type Calculator_Value_Server interface {
	Read(context.Context, Calculator_Value_read) error
}

// Calculator_Value_NewServer creates a new Server from an implementation of Calculator_Value_Server.
func Calculator_Value_NewServer(s Calculator_Value_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Calculator_Value_Methods(nil, s), s, c)
}

// Calculator_Value_ServerToClient creates a new Client from an implementation of Calculator_Value_Server.
// The caller is responsible for calling Release on the returned Client.
func Calculator_Value_ServerToClient(s Calculator_Value_Server) Calculator_Value {
	return Calculator_Value(capnp.NewClient(Calculator_Value_NewServer(s)))
}

// Calculator_Value_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Calculator_Value_Methods(methods []server.Method, s Calculator_Value_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xd46de288fc9d9427,
			MethodID:      0,
			InterfaceName: "src/calculator/calculator.capnp:Calculator.Value",
			MethodName:    "read",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Read(ctx, Calculator_Value_read{call})
		},
	})

	return methods
}

// Calculator_Value_read holds the state for a server call to Calculator_Value.read.
// See server.Call for documentation.
type Calculator_Value_read struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Calculator_Value_read) Args() Calculator_Value_read_Params {
	return Calculator_Value_read_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Calculator_Value_read) AllocResults() (Calculator_Value_read_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Calculator_Value_read_Results(r), err
}

// Calculator_Value_List is a list of Calculator_Value.
type Calculator_Value_List = capnp.CapList[Calculator_Value]

// NewCalculator_Value_List creates a new list of Calculator_Value.
func NewCalculator_Value_List(s *capnp.Segment, sz int32) (Calculator_Value_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Calculator_Value](l), err
}

type Calculator_Value_read_Params capnp.Struct

// Calculator_Value_read_Params_TypeID is the unique identifier for the type Calculator_Value_read_Params.
const Calculator_Value_read_Params_TypeID = 0xc150a9b67e205459

func NewCalculator_Value_read_Params(s *capnp.Segment) (Calculator_Value_read_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Calculator_Value_read_Params(st), err
}

func NewRootCalculator_Value_read_Params(s *capnp.Segment) (Calculator_Value_read_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Calculator_Value_read_Params(st), err
}

func ReadRootCalculator_Value_read_Params(msg *capnp.Message) (Calculator_Value_read_Params, error) {
	root, err := msg.Root()
	return Calculator_Value_read_Params(root.Struct()), err
}

func (s Calculator_Value_read_Params) String() string {
	str, _ := text.Marshal(0xc150a9b67e205459, capnp.Struct(s))
	return str
}

func (s Calculator_Value_read_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Calculator_Value_read_Params) DecodeFromPtr(p capnp.Ptr) Calculator_Value_read_Params {
	return Calculator_Value_read_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Calculator_Value_read_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Calculator_Value_read_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Calculator_Value_read_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Calculator_Value_read_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Calculator_Value_read_Params_List is a list of Calculator_Value_read_Params.
type Calculator_Value_read_Params_List = capnp.StructList[Calculator_Value_read_Params]

// NewCalculator_Value_read_Params creates a new list of Calculator_Value_read_Params.
func NewCalculator_Value_read_Params_List(s *capnp.Segment, sz int32) (Calculator_Value_read_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Calculator_Value_read_Params](l), err
}

// Calculator_Value_read_Params_Future is a wrapper for a Calculator_Value_read_Params promised by a client call.
type Calculator_Value_read_Params_Future struct{ *capnp.Future }

func (f Calculator_Value_read_Params_Future) Struct() (Calculator_Value_read_Params, error) {
	p, err := f.Future.Ptr()
	return Calculator_Value_read_Params(p.Struct()), err
}

type Calculator_Value_read_Results capnp.Struct

// Calculator_Value_read_Results_TypeID is the unique identifier for the type Calculator_Value_read_Results.
const Calculator_Value_read_Results_TypeID = 0xf0b94ba16ae580b3

func NewCalculator_Value_read_Results(s *capnp.Segment) (Calculator_Value_read_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Calculator_Value_read_Results(st), err
}

func NewRootCalculator_Value_read_Results(s *capnp.Segment) (Calculator_Value_read_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Calculator_Value_read_Results(st), err
}

func ReadRootCalculator_Value_read_Results(msg *capnp.Message) (Calculator_Value_read_Results, error) {
	root, err := msg.Root()
	return Calculator_Value_read_Results(root.Struct()), err
}

func (s Calculator_Value_read_Results) String() string {
	str, _ := text.Marshal(0xf0b94ba16ae580b3, capnp.Struct(s))
	return str
}

func (s Calculator_Value_read_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Calculator_Value_read_Results) DecodeFromPtr(p capnp.Ptr) Calculator_Value_read_Results {
	return Calculator_Value_read_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Calculator_Value_read_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Calculator_Value_read_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Calculator_Value_read_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Calculator_Value_read_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Calculator_Value_read_Results) Value() int32 {
	return int32(capnp.Struct(s).Uint32(0))
}

func (s Calculator_Value_read_Results) SetValue(v int32) {
	capnp.Struct(s).SetUint32(0, uint32(v))
}

// Calculator_Value_read_Results_List is a list of Calculator_Value_read_Results.
type Calculator_Value_read_Results_List = capnp.StructList[Calculator_Value_read_Results]

// NewCalculator_Value_read_Results creates a new list of Calculator_Value_read_Results.
func NewCalculator_Value_read_Results_List(s *capnp.Segment, sz int32) (Calculator_Value_read_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Calculator_Value_read_Results](l), err
}

// Calculator_Value_read_Results_Future is a wrapper for a Calculator_Value_read_Results promised by a client call.
type Calculator_Value_read_Results_Future struct{ *capnp.Future }

func (f Calculator_Value_read_Results_Future) Struct() (Calculator_Value_read_Results, error) {
	p, err := f.Future.Ptr()
	return Calculator_Value_read_Results(p.Struct()), err
}

const schema_e2dfedea92caa921 = "x\xda\x94SOHT_\x14>\xdf\xbdo\xbc.~" +
	"\xc3\xcc\xe5\xe9\xc2\xc5\x8f\xd1\x10LGM\x9d\\d\x82" +
	"c\x11\"R\xce\x93(l\xf7\x9ay\xd5\xc4S\xa77" +
	"\xef\xd9\xaeZ\x86P\x90\xb4i\xd1\xc2\x85\x0b\xdbE`" +
	"\x14\xb4h!D\x10\xb5h\xe3*\x14j!\x84\xe1\xba" +
	"\xbaq\xdf8\xbe\xa9$\x9d\xdd\xe1~\xe7\xcf\xf7}\xe7" +
	"\xdc\xbe\x8b\xc8\x1a\xfd\xf1\xf7\x9c\x98\xd5\x1dkP_\xc6" +
	"V\xad\xf8z\xfa>\xc9V\xae\xdaV\xde.n}\xfd" +
	"\xb4I\x84\xcc;\\\x82\xb9\x811\xa2\x8cd\x02\xe6S" +
	"&\x88\xd4\xf4\xf9\xd6[\xab+\xb9\xd7$\xfbAd\x08" +
	"\xa2\xcc#\xb6\x052\xd4\xf3\xb57\xc3\xaf\xc6_~ " +
	"\x99F\xd45\xa6\xab2\xf7\xd8\x13\x98\xcb:4\x97\xd8" +
	"M\x82\xeax\xf8\xf8\xfb\xdd\xcd\x99\x8f$\xd3<J&" +
	"d~\xb0\x05\x98\xcd\\gJ>f\x9e\xd0\x91\xf27" +
	"zN\xeeL\xc6\xb6\xc9J\xa3\xa6\xf7\x19\x08\x06\x96i" +
	"\xe3\x0b\xa8$\x9a\x83\\7O\x9f\x9b\x18\x1d\xee\xe8\xde" +
	"\xfe\x83\x094\x93\x07|\x11\xe6J\x98\xbc\xccG\x08\xea" +
	"\xd9\x9d\xcf\xd7\x97&^|#\xab\x1fUEk|\x07" +
	"\x04s\x9d\x8fP\x8f*{\xf9cy\xdb\xcd\x1b\x81k" +
	"\xfbs^\x18W\xc2\xde\xbc]\x9a-\x0d\x9d\xde}\xe0" +
	"s\x9e\x95\x04j\x8ch\x99\x8a\xa8\xcb\x96\x81\x1ab\xcd" +
	"C5\x16\xc8\x015>[\x0a\xfc\x9c]$x\xa90" +
	"\x1e\x99\x0c\xfcR\xe0\xa7.\xd8n\xe0XI\x1e#\xda" +
	"k\x8cj\x1fy\xe3\x081\xe9\x88\x9a\xa1\x116\xad\xb1" +
	"\xb3\x02l\x1flTc\x83\x02|\x1f\xacSc\xff\x0b" +
	"a\x17\x0aY\x88rp9\x0b1\x13\xb8Y\x88Bq" +
	">\x8b\x1c\xb0gI\xc3A\x96\xccy\xbd\xa1\x80^\xcf" +
	"\xb1\x0b\xed9;\xe1\xd93\xe5\xbd\xf2\xd8!\xcaC3" +
	"\x129\xbb\xe8\xe5\x00\xab\x91\x1bD\x06\x88dg\x17\x91" +
	"\xd5\xcea\xf51H\xa0I\xefN\xf6\x0c\x10YG9" +
	"\xac\xe3\x0c\x09\xd7\xb9\xe2#\x19-\x80\x80$!\xe5\x15" +
	"\xaf^\xdb\xe7\xbd.R\xa1&\"\xcd\xc8\x087S\xfd" +
	"\x15\xa8^\x93\x94]\xc4dL$\xb4\xf0\xdfM;\xb4" +
	"\xea\xca\x80Fn\xfc\xa7TE\xf3\xa9Hs\x1c?\xd5" +
	"\xdf\xa2o\xbbE\xdf\xf1l\x17\x061\x18\x84\xd4\xbcf" +
	"\x0a\x19\x1d\x1b\x01\xb2N\xb5\xe1%\xc2\xaf\xa8\xad\xfa\x1f" +
	"\xd7S\x1b9\xac&v\xf0\x94:\xefd\xcaI\x95\x03" +
	"\xd7/\xff{\xdc\xae\xc4_\x01\x00\x00\xff\xff\xed\xb8y" +
	"\xd4"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_e2dfedea92caa921,
		Nodes: []uint64{
			0x8e2bd90d51b647e6,
			0xc150a9b67e205459,
			0xd0ba49bd3cc8c5b7,
			0xd46de288fc9d9427,
			0xef054ff23b2de174,
			0xef2c273c414b4e2b,
			0xf0b94ba16ae580b3,
		},
		Compressed: true,
	})
}
